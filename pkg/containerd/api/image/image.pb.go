// Code generated by protoc-gen-gogo.
// source: image.proto
// DO NOT EDIT!

/*
Package image is a generated protocol buffer package.

It is generated from these files:
	image.proto

It has these top-level messages:
	PrepareRequest
	PrepareResponse
	CleanupRequest
	CleanupResponse
	CommitRequest
	CommitResponse
*/
package image

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import docker_containerkit_types "github.com/docker/containerkit/api/types/mount"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type PrepareRequest struct {
	// Path specifies the filesystem path to target for the image preparation.
	//
	// These will influence the values of "target" in the emitted mounts. It
	// must be unique per usage of the prepared mount and can only be prepared
	// again after a call to cleanup.
	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	// name of the image to prepare.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *PrepareRequest) Reset()                    { *m = PrepareRequest{} }
func (m *PrepareRequest) String() string            { return proto.CompactTextString(m) }
func (*PrepareRequest) ProtoMessage()               {}
func (*PrepareRequest) Descriptor() ([]byte, []int) { return fileDescriptorImage, []int{0} }

type PrepareResponse struct {
	// Layers provides a list of mounts to use with container creation. The
	// layers will be mounted, in order, assembling the root filesystem.
	//
	// Typically, these can be augmented with other mounts from the volume
	// service, tmpfs, application-specific bind mounts or even mounts from
	// other containers.
	Layers []*docker_containerkit_types.Mount `protobuf:"bytes,1,rep,name=layers" json:"layers,omitempty"`
}

func (m *PrepareResponse) Reset()                    { *m = PrepareResponse{} }
func (m *PrepareResponse) String() string            { return proto.CompactTextString(m) }
func (*PrepareResponse) ProtoMessage()               {}
func (*PrepareResponse) Descriptor() ([]byte, []int) { return fileDescriptorImage, []int{1} }

func (m *PrepareResponse) GetLayers() []*docker_containerkit_types.Mount {
	if m != nil {
		return m.Layers
	}
	return nil
}

type CleanupRequest struct {
	// Path cleans up the path used for the image.
	// ID identifies the prepared image to cleanup.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *CleanupRequest) Reset()                    { *m = CleanupRequest{} }
func (m *CleanupRequest) String() string            { return proto.CompactTextString(m) }
func (*CleanupRequest) ProtoMessage()               {}
func (*CleanupRequest) Descriptor() ([]byte, []int) { return fileDescriptorImage, []int{2} }

type CleanupResponse struct {
}

func (m *CleanupResponse) Reset()                    { *m = CleanupResponse{} }
func (m *CleanupResponse) String() string            { return proto.CompactTextString(m) }
func (*CleanupResponse) ProtoMessage()               {}
func (*CleanupResponse) Descriptor() ([]byte, []int) { return fileDescriptorImage, []int{3} }

// CommitRequest provides argument for the Commit RPC.
type CommitRequest struct {
	// Path to a prepared image to capture changes.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *CommitRequest) Reset()                    { *m = CommitRequest{} }
func (m *CommitRequest) String() string            { return proto.CompactTextString(m) }
func (*CommitRequest) ProtoMessage()               {}
func (*CommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorImage, []int{4} }

type CommitResponse struct {
	// name identifies the entity created as part of the image.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CommitResponse) Reset()                    { *m = CommitResponse{} }
func (m *CommitResponse) String() string            { return proto.CompactTextString(m) }
func (*CommitResponse) ProtoMessage()               {}
func (*CommitResponse) Descriptor() ([]byte, []int) { return fileDescriptorImage, []int{5} }

func init() {
	proto.RegisterType((*PrepareRequest)(nil), "docker.containerkit.types.PrepareRequest")
	proto.RegisterType((*PrepareResponse)(nil), "docker.containerkit.types.PrepareResponse")
	proto.RegisterType((*CleanupRequest)(nil), "docker.containerkit.types.CleanupRequest")
	proto.RegisterType((*CleanupResponse)(nil), "docker.containerkit.types.CleanupResponse")
	proto.RegisterType((*CommitRequest)(nil), "docker.containerkit.types.CommitRequest")
	proto.RegisterType((*CommitResponse)(nil), "docker.containerkit.types.CommitResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for Images service

type ImagesClient interface {
	// Prepare declares that an image is required for use. A prepared image,
	// complete with a set of mounts to use for the image will be provided.
	Prepare(ctx context.Context, in *PrepareRequest, opts ...grpc.CallOption) (*PrepareResponse, error)
	// Cleanup instructs the images service to cleanup resources for the image.
	Cleanup(ctx context.Context, in *CleanupRequest, opts ...grpc.CallOption) (*CleanupResponse, error)
	// Commit
	Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*CommitResponse, error)
}

type imagesClient struct {
	cc *grpc.ClientConn
}

func NewImagesClient(cc *grpc.ClientConn) ImagesClient {
	return &imagesClient{cc}
}

func (c *imagesClient) Prepare(ctx context.Context, in *PrepareRequest, opts ...grpc.CallOption) (*PrepareResponse, error) {
	out := new(PrepareResponse)
	err := grpc.Invoke(ctx, "/docker.containerkit.types.Images/Prepare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) Cleanup(ctx context.Context, in *CleanupRequest, opts ...grpc.CallOption) (*CleanupResponse, error) {
	out := new(CleanupResponse)
	err := grpc.Invoke(ctx, "/docker.containerkit.types.Images/Cleanup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*CommitResponse, error) {
	out := new(CommitResponse)
	err := grpc.Invoke(ctx, "/docker.containerkit.types.Images/Commit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Images service

type ImagesServer interface {
	// Prepare declares that an image is required for use. A prepared image,
	// complete with a set of mounts to use for the image will be provided.
	Prepare(context.Context, *PrepareRequest) (*PrepareResponse, error)
	// Cleanup instructs the images service to cleanup resources for the image.
	Cleanup(context.Context, *CleanupRequest) (*CleanupResponse, error)
	// Commit
	Commit(context.Context, *CommitRequest) (*CommitResponse, error)
}

func RegisterImagesServer(s *grpc.Server, srv ImagesServer) {
	s.RegisterService(&_Images_serviceDesc, srv)
}

func _Images_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/docker.containerkit.types.Images/Prepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).Prepare(ctx, req.(*PrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/docker.containerkit.types.Images/Cleanup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).Cleanup(ctx, req.(*CleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/docker.containerkit.types.Images/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).Commit(ctx, req.(*CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Images_serviceDesc = grpc.ServiceDesc{
	ServiceName: "docker.containerkit.types.Images",
	HandlerType: (*ImagesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Prepare",
			Handler:    _Images_Prepare_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _Images_Cleanup_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _Images_Commit_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptorImage = []byte{
	// 314 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x52, 0x4f, 0x6b, 0x3a, 0x31,
	0x14, 0x64, 0xf5, 0xc7, 0xca, 0xef, 0x49, 0x95, 0xe6, 0x64, 0xf7, 0x24, 0xdb, 0x1e, 0xb4, 0xd0,
	0x0d, 0xd8, 0x8b, 0xf4, 0xea, 0xa9, 0x94, 0x42, 0xf1, 0x5e, 0x30, 0xda, 0xd7, 0x35, 0x68, 0xfe,
	0x34, 0xc9, 0x1e, 0xfc, 0x4c, 0xfd, 0x92, 0x65, 0x93, 0xd4, 0x7f, 0xd0, 0xc5, 0xcb, 0xf2, 0x12,
	0x66, 0xe6, 0xcd, 0xcc, 0x06, 0xba, 0x5c, 0xb0, 0x12, 0x0b, 0x6d, 0x94, 0x53, 0xe4, 0xe6, 0x43,
	0xad, 0x36, 0x68, 0x8a, 0x95, 0x92, 0x8e, 0x71, 0x89, 0x66, 0xc3, 0x5d, 0xe1, 0x76, 0x1a, 0x6d,
	0xf6, 0x50, 0x72, 0xb7, 0xae, 0x96, 0xc5, 0x4a, 0x09, 0x5a, 0xaa, 0x52, 0x51, 0xcf, 0x58, 0x56,
	0x9f, 0xfe, 0xe4, 0x0f, 0x7e, 0x0a, 0x4a, 0xd9, 0xd3, 0x11, 0x3c, 0x88, 0xd2, 0x63, 0x51, 0xca,
	0x34, 0xa7, 0x5e, 0x98, 0x0a, 0x55, 0x49, 0x17, 0xbe, 0x81, 0x9b, 0x4f, 0xa1, 0xf7, 0x66, 0x50,
	0x33, 0x83, 0x73, 0xfc, 0xaa, 0xd0, 0x3a, 0x42, 0xe0, 0x9f, 0x66, 0x6e, 0x3d, 0x68, 0x0f, 0x93,
	0xd1, 0xff, 0xb9, 0x9f, 0xeb, 0x3b, 0xc9, 0x04, 0x0e, 0x5a, 0xe1, 0xae, 0x9e, 0xf3, 0x17, 0xe8,
	0xef, 0x99, 0x56, 0x2b, 0x69, 0x91, 0x4c, 0x21, 0xdd, 0xb2, 0x1d, 0x1a, 0x3b, 0x48, 0x86, 0xed,
	0x51, 0x77, 0x32, 0x2c, 0xfe, 0xcc, 0x58, 0xbc, 0xd6, 0x26, 0xe6, 0x11, 0x9f, 0xdf, 0x41, 0x6f,
	0xb6, 0x45, 0x26, 0x2b, 0x7d, 0x6e, 0x23, 0x39, 0xd8, 0xc8, 0xaf, 0xa1, 0xbf, 0x47, 0x85, 0x95,
	0xf9, 0x2d, 0x5c, 0xcd, 0x94, 0x10, 0xdc, 0x35, 0xf1, 0x6a, 0xf5, 0x08, 0x8a, 0x4e, 0x7f, 0x03,
	0x25, 0x87, 0x40, 0x93, 0xef, 0x16, 0xa4, 0xcf, 0xf5, 0x0f, 0xb2, 0x64, 0x01, 0x9d, 0x98, 0x8d,
	0x8c, 0x1b, 0x32, 0x9c, 0x36, 0x97, 0xdd, 0x5f, 0x02, 0x8d, 0x06, 0x16, 0xd0, 0x89, 0x51, 0x1a,
	0x37, 0x9c, 0x96, 0xd2, 0xb8, 0xe1, 0xac, 0x19, 0xf2, 0x0e, 0x69, 0x08, 0x4d, 0x46, 0x4d, 0xac,
	0xe3, 0xf2, 0xb2, 0xf1, 0x05, 0xc8, 0x20, 0xbf, 0x4c, 0xfd, 0xfb, 0x79, 0xfc, 0x09, 0x00, 0x00,
	0xff, 0xff, 0x28, 0x48, 0xab, 0xcd, 0xd4, 0x02, 0x00, 0x00,
}
